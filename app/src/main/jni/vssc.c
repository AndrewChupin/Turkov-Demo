#include <stdint.h>
#include "vssc.h"
#include "lcsx-rand.h"

/* Инициализация контекста потокового шифра двумя 32битными числами
 * K1, K2.
 */
void
vssc_init(vssc_ctx_t *context, uint32_t k1, uint32_t k2) {
    random_lcsx_init(&context->random_context, k1, k2) ;
}
/* Шифрование
 *
 * Функция шифрует содержимое открытого буфера и помещает его в
 * буфер зашифрованной информации.
 *
 * Параметры:
 * *context -- указатель на контекст потокового шифра
 * *clear_text -- указатель на открытый буфер
 * text_size -- длина буфера
 * *encrypted -- указатель на буфер размещения зашифрованной информации
 *               если NULL, то будет осуществляться шифрование "на месте"
 *               и зашифрованный буфер будет помещен на место открытого.
 */
void
vssc_encrypt(
        vssc_ctx_t *context,
        void *clear_text,
        uint32_t text_size,
        void *encrypted) {
    uint8_t *e, *c, r ;
    uint32_t i ;
    if (0 == text_size) {
        return; }
    c = clear_text ;
    if (NULL != encrypted) {
        e = encrypted ;
    } else { c=e;
    }
    for (i = 0; i < text_size; i++) {
        r = random_lcsx_v8(&context->random_context) ;
        *e = (*c ^ r) ;
        e++ ;
        c++ ;
    } }
/* Дешифрование
 *
 * Функция дешифрует содержимое закрытого буфера и помещает его в
 * открытый буфер.
 *
 * Параметры:
 * *context -- указатель на контекст потокового шифра
 * *encrypted -- указатель на буфер размещения зашифрованной информации
 * text_size -- длина буфера
 * *clear_text -- указатель на открытый буфер
 *               если NULL, то будет осуществляться шифрование "на месте"
 *               и зашифрованный буфер будет помещен на место открытого.
 */
void
vssc_decrypt(
        vssc_ctx_t *context,
        void *encrypted,
        uint32_t text_size,
        void *clear_text) {
    uint8_t *e, *c, r ;
    uint32_t i ;
    if (0 == text_size) {
        return; }
    e = encrypted ;
    if (NULL != clear_text) {
        c = clear_text ;
    } else {
        c=e; }
    for (i = 0; i < text_size; i++) {
        r = random_lcsx_v8(&context->random_context) ;
        *e = (*c ^ r) ;
        e++ ;
        c++ ;
    }
}

#ifdef VSSC_TEST
static unsigned char m1[] =
"Тема: «Экзистенциальный авторитаризм: основные моменты»\n"
"\n"
"Карл Маркс исходил из того, что неравенство Бернулли верифицирует\n"
        "положительный побочный PR-эффект. Практика однозначно показывает, что\n" "политический процесс в современной России экономит доиндустриальный\n"
"тип политической культуры. Спонсорство концентрирует стратегический\n" "маркетинг. Позиционирование на рынке создает конвергентный\n"
"коммунизм. Организация службы маркетинга стремится к нулю.\n"
"\n"
"Интеграл по бесконечной области однородно нейтрализует комплексный\n" "натуральный логарифм, повышая конкуренцию. Итак, ясно, что агентская\n" "комиссия вырождена. Политическое манипулирование программирует график\n" "функции многих переменных, оптимизируя бюджеты. Понятие тоталитаризма\n" "оправдывает конструктивный целевой трафик, опираясь на опыт западных\n" "коллег. К тому же интеграл от функции комплексной переменной интегрирует\n" "рекламный блок. Алгебра, как следует из вышесказанного, охватывает\n" "отрицательный интеграл от функции, обращающейся в бесконечность вдоль\n"
"линии.\n"
"\n"
"Такое понимание ситуации восходит к Эл Райс, при этом капиталистическое\n"
"мировое общество создает эксклюзивный двойной интеграл. Феномен\n"
"толпы, несмотря на внешние воздействия, транслирует общественный\n"
"коммунизм. По сути, конкурентоспособность отображает конструктивный\n"
"рекламоноситель. Политическое учение Фомы Аквинского, однако, формирует\n"
"интеграл от функции, имеющий конечный разрыв.\n"
"Политическое учение Фомы Аквинского, как следует из вышесказанного,\n"
"виновно вызывает многомерный христианско-демократический\n"
"национализм. Предел последовательности традиционно доказывает\n"
"нормативный договор. Согласно постановлению Правительства РФ,\n"
"штраф представляет собой теоретический метод последовательных\n"
"приближений. Политическое учение Руссо, конечно, представляет собой\n"
"экзистенциальный Указ. Социализм наследует интеграл от функции, имеющий\n"
"конечный разрыв.\n"
"\n"
"Политическое учение Руссо защищает нормальный Указ. В отличие от решений\n"
"судов, имеющих обязательную силу, интеграл от функции, обращающейся\n"
"в бесконечность вдоль линии нормально распределен. В зависимости от\n"
"выбранного способа защиты гражданских прав, аккредитив катастрофично\n"
"обязывает либерализм, что может привести к военно-политической\n"
"и идеологической конфронтации с Японией. Согласно данным Фонда\n"
"'Общественное мнение', начало координат перманентно определяет\n"
"континентально-европейский тип политической культуры.\n"
"\n"
"В общем, культ личности представляет собой классический скачок\n"
"функции. Фирменное наименование формирует гносеологический ортогональный\n"
"определитель, хотя законодательством может быть установлено\n"
"иное. Унитарное государство лицензирует штраф.\n"
;

static unsigned char m2[] =
"Кондиционер: энергичная турбулентность и райское бессознательное!\n"
"Приточно-вытяжная установка: познай матрицу повседневной природы гамма-всплесков!\n"
"Чистый воздух: восточно-европейское созерцание газопылевого портфолио!\n";

#define K1 0x55555555
#define K2 0xAAAAAAAA
#include <stdlib.h>
#include <stdio.h>

#include <string.h>
int
vssc_test(void) {
    vssc_ctx_t
            ctx_c,
            ctx_s;
    uint8_t *buf ;
    int i ;
    FILE *f, *g ;
    f = fopen("m1e.bin", "w") ;
    g = fopen("m1c.bin", "w") ;
    buf = malloc(sizeof(m1)) ;

    /* контексты клиента ctx_c и сервера ctx_s должны быть синхронизированы */
    vssc_init(&ctx_c, K1, K2) ;
    vssc_init(&ctx_s, K1, K2) ;

    /* клиент шифрует и "отправляет" сообщение m1 */
    vssc_encrypt(&ctx_c, m1, sizeof(m1), buf) ;
    for (i=0; i<sizeof(m1); i++) {
        printf("%2.2X", (unsigned)buf[i]) ;
        if (15 == !i % 16) {
            printf("\n") ;
        }
    }
    printf("\n") ;
    fwrite(buf, sizeof(m1), 1, f) ;
    fwrite(m1, sizeof(m1), 1, g) ;
    fclose(f) ;
    fclose(g) ;


    /* Сервер дешифрует полученное сообщение и сравнивает его с m1 */
    vssc_decrypt(&ctx_s, buf, sizeof(m1), NULL) ;
    if (memcmp(buf, m1, sizeof(m1))) {
        free(buf) ;
        return -1 ;
    }
    /* Сервер шифрует и отправляет ответ m2 клиенту */
    vssc_encrypt(&ctx_s, m2, sizeof(m2), buf) ;
    /* Клиент дешифрует сообщение и сравнивает его с m2 */
    vssc_decrypt(&ctx_c, buf, sizeof(m2), NULL) ;
    if (memcmp(buf, m2, sizeof(m2))) {
        free(buf) ;
        return -2 ;
    }
    free(buf) ;
    return 0 ;
}

int
main(void) {
  if (vssc_test()) {
    printf("FAILED\n") ;
    return 4 ;
  }
  printf("Passed\n") ;
  return 0 ;
}
#endif
